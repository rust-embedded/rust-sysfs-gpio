<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `AioCb` struct in crate `nix`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, AioCb">

    <title>nix::sys::aio::AioCb - Rust</title>

    <link rel="stylesheet" type="text/css" href="../../../normalize.css">
    <link rel="stylesheet" type="text/css" href="../../../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../../../main.css">
    

    
    
</head>
<body class="rustdoc struct">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        <div class="sidebar-menu">&#9776;</div>
        
        <p class='location'>Struct AioCb</p><div class="sidebar-elems"><div class="block items"><a class="sidebar-title" href="#methods">Methods</a><div class="sidebar-links"><a href="#method.buffer">buffer</a><a href="#method.fd">fd</a><a href="#method.from_fd">from_fd</a><a href="#method.from_mut_slice">from_mut_slice</a><a href="#method.from_bytes">from_bytes</a><a href="#method.from_bytes_mut">from_bytes_mut</a><a href="#method.from_mut_ptr">from_mut_ptr</a><a href="#method.from_ptr">from_ptr</a><a href="#method.from_slice">from_slice</a><a href="#method.into_buffer">into_buffer</a><a href="#method.set_sigev_notify">set_sigev_notify</a><a href="#method.cancel">cancel</a><a href="#method.error">error</a><a href="#method.fsync">fsync</a><a href="#method.lio_opcode">lio_opcode</a><a href="#method.nbytes">nbytes</a><a href="#method.offset">offset</a><a href="#method.priority">priority</a><a href="#method.read">read</a><a href="#method.sigevent">sigevent</a><a href="#method.aio_return">aio_return</a><a href="#method.write">write</a></div><a class="sidebar-title" href="#implementations">Trait Implementations</a><div class="sidebar-links"><a href="#impl-Debug">Debug</a><a href="#impl-Drop">Drop</a></div></div><p class='location'><a href='../../index.html'>nix</a>::<wbr><a href='../index.html'>sys</a>::<wbr><a href='index.html'>aio</a></p><script>window.sidebarCurrent = {name: 'AioCb', ty: 'struct', relpath: ''};</script><script defer src="sidebar-items.js"></script></div>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content">
<h1 class='fqn'><span class='in-band'>Struct <a href='../../index.html'>nix</a>::<wbr><a href='../index.html'>sys</a>::<wbr><a href='index.html'>aio</a>::<wbr><a class="struct" href=''>AioCb</a></span><span class='out-of-band'><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a class='srclink' href='../../../src/nix/sys/aio.rs.html#143-154' title='goto source code'>[src]</a></span></h1>
<pre class='rust struct'>pub struct AioCb&lt;'a&gt; { /* fields omitted */ }</pre><div class='docblock'><p>AIO Control Block.</p>

<p>The basic structure used by all aio functions.  Each <code>AioCb</code> represents one
I/O request.</p>
</div>
                    <h2 id='methods' class='small-section-header'>
                      Methods<a href='#methods' class='anchor'></a>
                    </h2>
                <h3 id='impl' class='impl'><span class='in-band'><code>impl&lt;'a&gt; <a class="struct" href="../../../nix/sys/aio/struct.AioCb.html" title="struct nix::sys::aio::AioCb">AioCb</a>&lt;'a&gt;</code><a href='#impl' class='anchor'></a></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../../src/nix/sys/aio.rs.html#156-863' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.buffer' class="method"><span id='buffer.v' class='invisible'><code>pub fn <a href='#method.buffer' class='fnname'>buffer</a>(&amp;mut self) -&gt; <a class="enum" href="../../../nix/sys/aio/enum.Buffer.html" title="enum nix::sys::aio::Buffer">Buffer</a>&lt;'a&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../../src/nix/sys/aio.rs.html#161-166' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p>Remove the inner <code>Buffer</code> and return it</p>

<p>It is an error to call this method while the <code>AioCb</code> is still in
progress.</p>
</div><h4 id='method.fd' class="method"><span id='fd.v' class='invisible'><code>pub fn <a href='#method.fd' class='fnname'>fd</a>(&amp;self) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/sys/unix/ext/io/type.RawFd.html" title="type std::sys::unix::ext::io::RawFd">RawFd</a></code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../../src/nix/sys/aio.rs.html#169-171' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p>Returns the underlying file descriptor associated with the <code>AioCb</code></p>
</div><h4 id='method.from_fd' class="method"><span id='from_fd.v' class='invisible'><code>pub fn <a href='#method.from_fd' class='fnname'>from_fd</a>(fd: <a class="type" href="https://doc.rust-lang.org/nightly/std/sys/unix/ext/io/type.RawFd.html" title="type std::sys::unix::ext::io::RawFd">RawFd</a>, prio: <a class="type" href="../../../libc/type.c_int.html" title="type libc::c_int">c_int</a>, sigev_notify: <a class="enum" href="../../../nix/sys/signal/enum.SigevNotify.html" title="enum nix::sys::signal::SigevNotify">SigevNotify</a>) -&gt; <a class="struct" href="../../../nix/sys/aio/struct.AioCb.html" title="struct nix::sys::aio::AioCb">AioCb</a>&lt;'a&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../../src/nix/sys/aio.rs.html#211-224' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p>Constructs a new <code>AioCb</code> with no associated buffer.</p>

<p>The resulting <code>AioCb</code> structure is suitable for use with <code>AioCb::fsync</code>.</p>

<h1 id='parameters' class='section-header'><a href='#parameters'>Parameters</a></h1>
<ul>
<li><code>fd</code>:           File descriptor.  Required for all aio functions.</li>
<li><code>prio</code>:         If POSIX Prioritized IO is supported, then the
              operation will be prioritized at the process&#39;s
              priority level minus <code>prio</code>.</li>
<li><code>sigev_notify</code>: Determines how you will be notified of event
               completion.</li>
</ul>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1>
<p>Create an <code>AioCb</code> from a raw file descriptor and use it for an
<a href="#method.from_bytes_mut"><code>fsync</code></a> operation.</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">f</span> <span class="op">=</span> <span class="ident">tempfile</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">aiocb</span> <span class="op">=</span> <span class="ident">AioCb</span>::<span class="ident">from_fd</span>( <span class="ident">f</span>.<span class="ident">as_raw_fd</span>(), <span class="number">0</span>, <span class="ident">SigevNone</span>);
<span class="ident">aiocb</span>.<span class="ident">fsync</span>(<span class="ident">AioFsyncMode</span>::<span class="ident">O_SYNC</span>).<span class="ident">expect</span>(<span class="string">&quot;aio_fsync failed early&quot;</span>);
<span class="kw">while</span> (<span class="ident">aiocb</span>.<span class="ident">error</span>() <span class="op">==</span> <span class="prelude-val">Err</span>(<span class="ident">Error</span>::<span class="ident">from</span>(<span class="ident">Errno</span>::<span class="ident">EINPROGRESS</span>))) {
    <span class="ident">thread</span>::<span class="ident">sleep</span>(<span class="ident">time</span>::<span class="ident">Duration</span>::<span class="ident">from_millis</span>(<span class="number">10</span>));
}
<span class="ident">aiocb</span>.<span class="ident">aio_return</span>().<span class="ident">expect</span>(<span class="string">&quot;aio_fsync failed late&quot;</span>);</pre>
</div><h4 id='method.from_mut_slice' class="method"><span id='from_mut_slice.v' class='invisible'><code>pub fn <a href='#method.from_mut_slice' class='fnname'>from_mut_slice</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;fd: <a class="type" href="https://doc.rust-lang.org/nightly/std/sys/unix/ext/io/type.RawFd.html" title="type std::sys::unix::ext::io::RawFd">RawFd</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;offs: <a class="type" href="../../../libc/unix/notbsd/linux/other/b64/type.off_t.html" title="type libc::unix::notbsd::linux::other::b64::off_t">off_t</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;buf: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'a mut [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;prio: <a class="type" href="../../../libc/type.c_int.html" title="type libc::c_int">c_int</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;sigev_notify: <a class="enum" href="../../../nix/sys/signal/enum.SigevNotify.html" title="enum nix::sys::signal::SigevNotify">SigevNotify</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;opcode: <a class="enum" href="../../../nix/sys/aio/enum.LioOpcode.html" title="enum nix::sys::aio::LioOpcode">LioOpcode</a><br>) -&gt; <a class="struct" href="../../../nix/sys/aio/struct.AioCb.html" title="struct nix::sys::aio::AioCb">AioCb</a>&lt;'a&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../../src/nix/sys/aio.rs.html#285-300' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p>Constructs a new <code>AioCb</code> from a mutable slice.</p>

<p>The resulting <code>AioCb</code> will be suitable for both read and write
operations, but only if the borrow checker can guarantee that the slice
will outlive the <code>AioCb</code>.  That will usually be the case if the <code>AioCb</code>
is stack-allocated.  If the borrow checker gives you trouble, try using
<a href="#method.from_bytes_mut"><code>from_bytes_mut</code></a> instead.</p>

<h1 id='parameters-1' class='section-header'><a href='#parameters-1'>Parameters</a></h1>
<ul>
<li><code>fd</code>:           File descriptor.  Required for all aio functions.</li>
<li><code>offs</code>:         File offset</li>
<li><code>buf</code>:          A memory buffer</li>
<li><code>prio</code>:         If POSIX Prioritized IO is supported, then the
              operation will be prioritized at the process&#39;s
              priority level minus <code>prio</code></li>
<li><code>sigev_notify</code>: Determines how you will be notified of event
              completion.</li>
<li><code>opcode</code>:       This field is only used for <code>lio_listio</code>.  It
              determines which operation to use for this individual
              aiocb</li>
</ul>

<h1 id='examples-1' class='section-header'><a href='#examples-1'>Examples</a></h1>
<p>Create an <code>AioCb</code> from a mutable slice and read into it.</p>

<pre class="rust rust-example-rendered">
<span class="kw">const</span> <span class="ident">INITIAL</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>] <span class="op">=</span> <span class="string">b&quot;abcdef123456&quot;</span>;
<span class="kw">const</span> <span class="ident">LEN</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="number">4</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rbuf</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">0</span>; <span class="ident">LEN</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">f</span> <span class="op">=</span> <span class="ident">tempfile</span>().<span class="ident">unwrap</span>();
<span class="ident">f</span>.<span class="ident">write_all</span>(<span class="ident">INITIAL</span>).<span class="ident">unwrap</span>();
{
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">aiocb</span> <span class="op">=</span> <span class="ident">AioCb</span>::<span class="ident">from_mut_slice</span>( <span class="ident">f</span>.<span class="ident">as_raw_fd</span>(),
        <span class="number">2</span>,   <span class="comment">//offset</span>
        <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">rbuf</span>,
        <span class="number">0</span>,   <span class="comment">//priority</span>
        <span class="ident">SigevNotify</span>::<span class="ident">SigevNone</span>,
        <span class="ident">LioOpcode</span>::<span class="ident">LIO_NOP</span>);
    <span class="ident">aiocb</span>.<span class="ident">read</span>().<span class="ident">unwrap</span>();
    <span class="kw">while</span> (<span class="ident">aiocb</span>.<span class="ident">error</span>() <span class="op">==</span> <span class="prelude-val">Err</span>(<span class="ident">Error</span>::<span class="ident">from</span>(<span class="ident">Errno</span>::<span class="ident">EINPROGRESS</span>))) {
        <span class="ident">thread</span>::<span class="ident">sleep</span>(<span class="ident">time</span>::<span class="ident">Duration</span>::<span class="ident">from_millis</span>(<span class="number">10</span>));
    }
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">aiocb</span>.<span class="ident">aio_return</span>().<span class="ident">unwrap</span>() <span class="kw">as</span> <span class="ident">usize</span>, <span class="ident">LEN</span>);
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">rbuf</span>, <span class="string">b&quot;cdef&quot;</span>);</pre>
</div><h4 id='method.from_bytes' class="method"><span id='from_bytes.v' class='invisible'><code>pub fn <a href='#method.from_bytes' class='fnname'>from_bytes</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;fd: <a class="type" href="https://doc.rust-lang.org/nightly/std/sys/unix/ext/io/type.RawFd.html" title="type std::sys::unix::ext::io::RawFd">RawFd</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;offs: <a class="type" href="../../../libc/unix/notbsd/linux/other/b64/type.off_t.html" title="type libc::unix::notbsd::linux::other::b64::off_t">off_t</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;buf: <a class="struct" href="../../../bytes/bytes/struct.Bytes.html" title="struct bytes::bytes::Bytes">Bytes</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;prio: <a class="type" href="../../../libc/type.c_int.html" title="type libc::c_int">c_int</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;sigev_notify: <a class="enum" href="../../../nix/sys/signal/enum.SigevNotify.html" title="enum nix::sys::signal::SigevNotify">SigevNotify</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;opcode: <a class="enum" href="../../../nix/sys/aio/enum.LioOpcode.html" title="enum nix::sys::aio::LioOpcode">LioOpcode</a><br>) -&gt; <a class="struct" href="../../../nix/sys/aio/struct.AioCb.html" title="struct nix::sys::aio::AioCb">AioCb</a>&lt;'a&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../../src/nix/sys/aio.rs.html#355-384' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p>Constructs a new <code>AioCb</code> from a <code>Bytes</code> object.</p>

<p>Unlike <code>from_slice</code>, this method returns a structure suitable for
placement on the heap.  It may be used for write operations, but not
read operations.</p>

<h1 id='parameters-2' class='section-header'><a href='#parameters-2'>Parameters</a></h1>
<ul>
<li><code>fd</code>:           File descriptor.  Required for all aio functions.</li>
<li><code>offs</code>:         File offset</li>
<li><code>buf</code>:          A shared memory buffer</li>
<li><code>prio</code>:         If POSIX Prioritized IO is supported, then the
              operation will be prioritized at the process&#39;s
              priority level minus <code>prio</code></li>
<li><code>sigev_notify</code>: Determines how you will be notified of event
              completion.</li>
<li><code>opcode</code>:       This field is only used for <code>lio_listio</code>.  It
              determines which operation to use for this individual
              aiocb</li>
</ul>

<h1 id='examples-2' class='section-header'><a href='#examples-2'>Examples</a></h1>
<p>Create an <code>AioCb</code> from a <code>Bytes</code> object and use it for writing.</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">wbuf</span> <span class="op">=</span> <span class="ident">Bytes</span>::<span class="ident">from</span>(<span class="kw-2">&amp;</span><span class="string">b&quot;CDEF&quot;</span>[..]);
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">f</span> <span class="op">=</span> <span class="ident">tempfile</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">aiocb</span> <span class="op">=</span> <span class="ident">AioCb</span>::<span class="ident">from_bytes</span>( <span class="ident">f</span>.<span class="ident">as_raw_fd</span>(),
    <span class="number">2</span>,   <span class="comment">//offset</span>
    <span class="ident">wbuf</span>.<span class="ident">clone</span>(),
    <span class="number">0</span>,   <span class="comment">//priority</span>
    <span class="ident">SigevNotify</span>::<span class="ident">SigevNone</span>,
    <span class="ident">LioOpcode</span>::<span class="ident">LIO_NOP</span>);
<span class="ident">aiocb</span>.<span class="ident">write</span>().<span class="ident">unwrap</span>();
<span class="kw">while</span> (<span class="ident">aiocb</span>.<span class="ident">error</span>() <span class="op">==</span> <span class="prelude-val">Err</span>(<span class="ident">Error</span>::<span class="ident">from</span>(<span class="ident">Errno</span>::<span class="ident">EINPROGRESS</span>))) {
    <span class="ident">thread</span>::<span class="ident">sleep</span>(<span class="ident">time</span>::<span class="ident">Duration</span>::<span class="ident">from_millis</span>(<span class="number">10</span>));
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">aiocb</span>.<span class="ident">aio_return</span>().<span class="ident">unwrap</span>() <span class="kw">as</span> <span class="ident">usize</span>, <span class="ident">wbuf</span>.<span class="ident">len</span>());</pre>
</div><h4 id='method.from_bytes_mut' class="method"><span id='from_bytes_mut.v' class='invisible'><code>pub fn <a href='#method.from_bytes_mut' class='fnname'>from_bytes_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;fd: <a class="type" href="https://doc.rust-lang.org/nightly/std/sys/unix/ext/io/type.RawFd.html" title="type std::sys::unix::ext::io::RawFd">RawFd</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;offs: <a class="type" href="../../../libc/unix/notbsd/linux/other/b64/type.off_t.html" title="type libc::unix::notbsd::linux::other::b64::off_t">off_t</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;buf: <a class="struct" href="../../../bytes/bytes/struct.BytesMut.html" title="struct bytes::bytes::BytesMut">BytesMut</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;prio: <a class="type" href="../../../libc/type.c_int.html" title="type libc::c_int">c_int</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;sigev_notify: <a class="enum" href="../../../nix/sys/signal/enum.SigevNotify.html" title="enum nix::sys::signal::SigevNotify">SigevNotify</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;opcode: <a class="enum" href="../../../nix/sys/aio/enum.LioOpcode.html" title="enum nix::sys::aio::LioOpcode">LioOpcode</a><br>) -&gt; <a class="struct" href="../../../nix/sys/aio/struct.AioCb.html" title="struct nix::sys::aio::AioCb">AioCb</a>&lt;'a&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../../src/nix/sys/aio.rs.html#446-469' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p>Constructs a new <code>AioCb</code> from a <code>BytesMut</code> object.</p>

<p>Unlike <code>from_mut_slice</code>, this method returns a structure suitable for
placement on the heap.  It may be used for both reads and writes.</p>

<h1 id='parameters-3' class='section-header'><a href='#parameters-3'>Parameters</a></h1>
<ul>
<li><code>fd</code>:           File descriptor.  Required for all aio functions.</li>
<li><code>offs</code>:         File offset</li>
<li><code>buf</code>:          An owned memory buffer</li>
<li><code>prio</code>:         If POSIX Prioritized IO is supported, then the
              operation will be prioritized at the process&#39;s
              priority level minus <code>prio</code></li>
<li><code>sigev_notify</code>: Determines how you will be notified of event
              completion.</li>
<li><code>opcode</code>:       This field is only used for <code>lio_listio</code>.  It
              determines which operation to use for this individual
              aiocb</li>
</ul>

<h1 id='examples-3' class='section-header'><a href='#examples-3'>Examples</a></h1>
<p>Create an <code>AioCb</code> from a <code>BytesMut</code> and use it for reading.  In this
example the <code>AioCb</code> is stack-allocated, so we could&#39;ve used
<code>from_mut_slice</code> instead.</p>

<pre class="rust rust-example-rendered">
<span class="kw">const</span> <span class="ident">INITIAL</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>] <span class="op">=</span> <span class="string">b&quot;abcdef123456&quot;</span>;
<span class="kw">const</span> <span class="ident">LEN</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="number">4</span>;
<span class="kw">let</span> <span class="ident">rbuf</span> <span class="op">=</span> <span class="ident">BytesMut</span>::<span class="ident">from</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="number">0</span>; <span class="ident">LEN</span>]);
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">f</span> <span class="op">=</span> <span class="ident">tempfile</span>().<span class="ident">unwrap</span>();
<span class="ident">f</span>.<span class="ident">write_all</span>(<span class="ident">INITIAL</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">aiocb</span> <span class="op">=</span> <span class="ident">AioCb</span>::<span class="ident">from_bytes_mut</span>( <span class="ident">f</span>.<span class="ident">as_raw_fd</span>(),
    <span class="number">2</span>,   <span class="comment">//offset</span>
    <span class="ident">rbuf</span>,
    <span class="number">0</span>,   <span class="comment">//priority</span>
    <span class="ident">SigevNotify</span>::<span class="ident">SigevNone</span>,
    <span class="ident">LioOpcode</span>::<span class="ident">LIO_NOP</span>);
<span class="ident">aiocb</span>.<span class="ident">read</span>().<span class="ident">unwrap</span>();
<span class="kw">while</span> (<span class="ident">aiocb</span>.<span class="ident">error</span>() <span class="op">==</span> <span class="prelude-val">Err</span>(<span class="ident">Error</span>::<span class="ident">from</span>(<span class="ident">Errno</span>::<span class="ident">EINPROGRESS</span>))) {
    <span class="ident">thread</span>::<span class="ident">sleep</span>(<span class="ident">time</span>::<span class="ident">Duration</span>::<span class="ident">from_millis</span>(<span class="number">10</span>));
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">aiocb</span>.<span class="ident">aio_return</span>().<span class="ident">unwrap</span>() <span class="kw">as</span> <span class="ident">usize</span>, <span class="ident">LEN</span>);
<span class="kw">let</span> <span class="ident">buffer</span> <span class="op">=</span> <span class="ident">aiocb</span>.<span class="ident">into_buffer</span>();
<span class="kw">const</span> <span class="ident">EXPECT</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>] <span class="op">=</span> <span class="string">b&quot;cdef&quot;</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">buffer</span>.<span class="ident">bytes_mut</span>().<span class="ident">unwrap</span>(), <span class="ident">EXPECT</span>);</pre>
</div><h4 id='method.from_mut_ptr' class="method"><span id='from_mut_ptr.v' class='invisible'><code>pub unsafe fn <a href='#method.from_mut_ptr' class='fnname'>from_mut_ptr</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;fd: <a class="type" href="https://doc.rust-lang.org/nightly/std/sys/unix/ext/io/type.RawFd.html" title="type std::sys::unix::ext::io::RawFd">RawFd</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;offs: <a class="type" href="../../../libc/unix/notbsd/linux/other/b64/type.off_t.html" title="type libc::unix::notbsd::linux::other::b64::off_t">off_t</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;buf: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut </a><a class="enum" href="../../../libc/enum.c_void.html" title="enum libc::c_void">c_void</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;len: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;prio: <a class="type" href="../../../libc/type.c_int.html" title="type libc::c_int">c_int</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;sigev_notify: <a class="enum" href="../../../nix/sys/signal/enum.SigevNotify.html" title="enum nix::sys::signal::SigevNotify">SigevNotify</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;opcode: <a class="enum" href="../../../nix/sys/aio/enum.LioOpcode.html" title="enum nix::sys::aio::LioOpcode">LioOpcode</a><br>) -&gt; <a class="struct" href="../../../nix/sys/aio/struct.AioCb.html" title="struct nix::sys::aio::AioCb">AioCb</a>&lt;'a&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../../src/nix/sys/aio.rs.html#498-514' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p>Constructs a new <code>AioCb</code> from a mutable raw pointer</p>

<p>Unlike <code>from_mut_slice</code>, this method returns a structure suitable for
placement on the heap.  It may be used for both reads and writes.  Due
to its unsafety, this method is not recommended.  It is most useful when
heap allocation is required but for some reason the data cannot be
converted to a <code>BytesMut</code>.</p>

<h1 id='parameters-4' class='section-header'><a href='#parameters-4'>Parameters</a></h1>
<ul>
<li><code>fd</code>:           File descriptor.  Required for all aio functions.</li>
<li><code>offs</code>:         File offset</li>
<li><code>buf</code>:          Pointer to the memory buffer</li>
<li><code>len</code>:          Length of the buffer pointed to by <code>buf</code></li>
<li><code>prio</code>:         If POSIX Prioritized IO is supported, then the
              operation will be prioritized at the process&#39;s
              priority level minus <code>prio</code></li>
<li><code>sigev_notify</code>: Determines how you will be notified of event
              completion.</li>
<li><code>opcode</code>:       This field is only used for <code>lio_listio</code>.  It
              determines which operation to use for this individual
              aiocb</li>
</ul>

<h1 id='safety' class='section-header'><a href='#safety'>Safety</a></h1>
<p>The caller must ensure that the storage pointed to by <code>buf</code> outlives the
<code>AioCb</code>.  The lifetime checker can&#39;t help here.</p>
</div><h4 id='method.from_ptr' class="method"><span id='from_ptr.v' class='invisible'><code>pub unsafe fn <a href='#method.from_ptr' class='fnname'>from_ptr</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;fd: <a class="type" href="https://doc.rust-lang.org/nightly/std/sys/unix/ext/io/type.RawFd.html" title="type std::sys::unix::ext::io::RawFd">RawFd</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;offs: <a class="type" href="../../../libc/unix/notbsd/linux/other/b64/type.off_t.html" title="type libc::unix::notbsd::linux::other::b64::off_t">off_t</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;buf: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*const </a><a class="enum" href="../../../libc/enum.c_void.html" title="enum libc::c_void">c_void</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;len: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;prio: <a class="type" href="../../../libc/type.c_int.html" title="type libc::c_int">c_int</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;sigev_notify: <a class="enum" href="../../../nix/sys/signal/enum.SigevNotify.html" title="enum nix::sys::signal::SigevNotify">SigevNotify</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;opcode: <a class="enum" href="../../../nix/sys/aio/enum.LioOpcode.html" title="enum nix::sys::aio::LioOpcode">LioOpcode</a><br>) -&gt; <a class="struct" href="../../../nix/sys/aio/struct.AioCb.html" title="struct nix::sys::aio::AioCb">AioCb</a>&lt;'a&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../../src/nix/sys/aio.rs.html#542-560' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p>Constructs a new <code>AioCb</code> from a raw pointer.</p>

<p>Unlike <code>from_slice</code>, this method returns a structure suitable for
placement on the heap.  Due to its unsafety, this method is not
recommended.  It is most useful when heap allocation is required but for
some reason the data cannot be converted to a <code>Bytes</code>.</p>

<h1 id='parameters-5' class='section-header'><a href='#parameters-5'>Parameters</a></h1>
<ul>
<li><code>fd</code>:           File descriptor.  Required for all aio functions.</li>
<li><code>offs</code>:         File offset</li>
<li><code>buf</code>:          Pointer to the memory buffer</li>
<li><code>len</code>:          Length of the buffer pointed to by <code>buf</code></li>
<li><code>prio</code>:         If POSIX Prioritized IO is supported, then the
              operation will be prioritized at the process&#39;s
              priority level minus <code>prio</code></li>
<li><code>sigev_notify</code>: Determines how you will be notified of event
              completion.</li>
<li><code>opcode</code>:       This field is only used for <code>lio_listio</code>.  It
              determines which operation to use for this individual
              aiocb</li>
</ul>

<h1 id='safety-1' class='section-header'><a href='#safety-1'>Safety</a></h1>
<p>The caller must ensure that the storage pointed to by <code>buf</code> outlives the
<code>AioCb</code>.  The lifetime checker can&#39;t help here.</p>
</div><h4 id='method.from_slice' class="method"><span id='from_slice.v' class='invisible'><code>pub fn <a href='#method.from_slice' class='fnname'>from_slice</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;fd: <a class="type" href="https://doc.rust-lang.org/nightly/std/sys/unix/ext/io/type.RawFd.html" title="type std::sys::unix::ext::io::RawFd">RawFd</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;offs: <a class="type" href="../../../libc/unix/notbsd/linux/other/b64/type.off_t.html" title="type libc::unix::notbsd::linux::other::b64::off_t">off_t</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;buf: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'a [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;prio: <a class="type" href="../../../libc/type.c_int.html" title="type libc::c_int">c_int</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;sigev_notify: <a class="enum" href="../../../nix/sys/signal/enum.SigevNotify.html" title="enum nix::sys::signal::SigevNotify">SigevNotify</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;opcode: <a class="enum" href="../../../nix/sys/aio/enum.LioOpcode.html" title="enum nix::sys::aio::LioOpcode">LioOpcode</a><br>) -&gt; <a class="struct" href="../../../nix/sys/aio/struct.AioCb.html" title="struct nix::sys::aio::AioCb">AioCb</a></code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../../src/nix/sys/aio.rs.html#605-624' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p>Like <code>from_mut_slice</code>, but works on constant slices rather than
mutable slices.</p>

<p>An <code>AioCb</code> created this way cannot be used with <code>read</code>, and its
<code>LioOpcode</code> cannot be set to <code>LIO_READ</code>.  This method is useful when
writing a const buffer with <code>AioCb::write</code>, since <code>from_mut_slice</code> can&#39;t
work with const buffers.</p>

<h1 id='examples-4' class='section-header'><a href='#examples-4'>Examples</a></h1>
<p>Construct an <code>AioCb</code> from a slice and use it for writing.</p>

<pre class="rust rust-example-rendered">
<span class="kw">const</span> <span class="ident">WBUF</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>] <span class="op">=</span> <span class="string">b&quot;abcdef123456&quot;</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">f</span> <span class="op">=</span> <span class="ident">tempfile</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">aiocb</span> <span class="op">=</span> <span class="ident">AioCb</span>::<span class="ident">from_slice</span>( <span class="ident">f</span>.<span class="ident">as_raw_fd</span>(),
    <span class="number">2</span>,   <span class="comment">//offset</span>
    <span class="ident">WBUF</span>,
    <span class="number">0</span>,   <span class="comment">//priority</span>
    <span class="ident">SigevNotify</span>::<span class="ident">SigevNone</span>,
    <span class="ident">LioOpcode</span>::<span class="ident">LIO_NOP</span>);
<span class="ident">aiocb</span>.<span class="ident">write</span>().<span class="ident">unwrap</span>();
<span class="kw">while</span> (<span class="ident">aiocb</span>.<span class="ident">error</span>() <span class="op">==</span> <span class="prelude-val">Err</span>(<span class="ident">Error</span>::<span class="ident">from</span>(<span class="ident">Errno</span>::<span class="ident">EINPROGRESS</span>))) {
    <span class="ident">thread</span>::<span class="ident">sleep</span>(<span class="ident">time</span>::<span class="ident">Duration</span>::<span class="ident">from_millis</span>(<span class="number">10</span>));
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">aiocb</span>.<span class="ident">aio_return</span>().<span class="ident">unwrap</span>() <span class="kw">as</span> <span class="ident">usize</span>, <span class="ident">WBUF</span>.<span class="ident">len</span>());</pre>
</div><h4 id='method.into_buffer' class="method"><span id='into_buffer.v' class='invisible'><code>pub fn <a href='#method.into_buffer' class='fnname'>into_buffer</a>(self) -&gt; <a class="enum" href="../../../nix/sys/aio/enum.Buffer.html" title="enum nix::sys::aio::Buffer">Buffer</a>&lt;'static&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../../src/nix/sys/aio.rs.html#630-637' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p>Consumes the <code>aiocb</code> and returns its inner <code>Buffer</code>, if any.</p>

<p>This method is especially useful when reading into a <code>BytesMut</code>, because
that type does not support shared ownership.</p>
</div><h4 id='method.set_sigev_notify' class="method"><span id='set_sigev_notify.v' class='invisible'><code>pub fn <a href='#method.set_sigev_notify' class='fnname'>set_sigev_notify</a>(&amp;mut self, sigev_notify: <a class="enum" href="../../../nix/sys/signal/enum.SigevNotify.html" title="enum nix::sys::signal::SigevNotify">SigevNotify</a>)</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../../src/nix/sys/aio.rs.html#653-655' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p>Update the notification settings for an existing <code>aiocb</code></p>
</div><h4 id='method.cancel' class="method"><span id='cancel.v' class='invisible'><code>pub fn <a href='#method.cancel' class='fnname'>cancel</a>(&amp;mut self) -&gt; <a class="type" href="../../../nix/type.Result.html" title="type nix::Result">Result</a>&lt;<a class="enum" href="../../../nix/sys/aio/enum.AioCancelStat.html" title="enum nix::sys::aio::AioCancelStat">AioCancelStat</a>&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../../src/nix/sys/aio.rs.html#708-716' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p>Cancels an outstanding AIO request.</p>

<p>The operating system is not required to implement cancellation for all
file and device types.  Even if it does, there is no guarantee that the
operation has not already completed.  So the caller must check the
result and handle operations that were not canceled or that have already
completed.</p>

<h1 id='examples-5' class='section-header'><a href='#examples-5'>Examples</a></h1>
<p>Cancel an outstanding aio operation.  Note that we must still call
<code>aio_return</code> to free resources, even though we don&#39;t care about the
result.</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">wbuf</span> <span class="op">=</span> <span class="ident">Bytes</span>::<span class="ident">from</span>(<span class="kw-2">&amp;</span><span class="string">b&quot;CDEF&quot;</span>[..]);
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">f</span> <span class="op">=</span> <span class="ident">tempfile</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">aiocb</span> <span class="op">=</span> <span class="ident">AioCb</span>::<span class="ident">from_bytes</span>( <span class="ident">f</span>.<span class="ident">as_raw_fd</span>(),
    <span class="number">2</span>,   <span class="comment">//offset</span>
    <span class="ident">wbuf</span>.<span class="ident">clone</span>(),
    <span class="number">0</span>,   <span class="comment">//priority</span>
    <span class="ident">SigevNotify</span>::<span class="ident">SigevNone</span>,
    <span class="ident">LioOpcode</span>::<span class="ident">LIO_NOP</span>);
<span class="ident">aiocb</span>.<span class="ident">write</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">cs</span> <span class="op">=</span> <span class="ident">aiocb</span>.<span class="ident">cancel</span>().<span class="ident">unwrap</span>();
<span class="kw">if</span> <span class="ident">cs</span> <span class="op">==</span> <span class="ident">AioCancelStat</span>::<span class="ident">AioNotCanceled</span> {
    <span class="kw">while</span> (<span class="ident">aiocb</span>.<span class="ident">error</span>() <span class="op">==</span> <span class="prelude-val">Err</span>(<span class="ident">Error</span>::<span class="ident">from</span>(<span class="ident">Errno</span>::<span class="ident">EINPROGRESS</span>))) {
        <span class="ident">thread</span>::<span class="ident">sleep</span>(<span class="ident">time</span>::<span class="ident">Duration</span>::<span class="ident">from_millis</span>(<span class="number">10</span>));
    }
}
<span class="comment">// Must call `aio_return`, but ignore the result</span>
<span class="kw">let</span> _ <span class="op">=</span> <span class="ident">aiocb</span>.<span class="ident">aio_return</span>();</pre>

<h1 id='references' class='section-header'><a href='#references'>References</a></h1>
<p><a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/aio_cancel.html">aio_cancel</a></p>
</div><h4 id='method.error' class="method"><span id='error.v' class='invisible'><code>pub fn <a href='#method.error' class='fnname'>error</a>(&amp;mut self) -&gt; <a class="type" href="../../../nix/type.Result.html" title="type nix::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../../src/nix/sys/aio.rs.html#758-765' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p>Retrieve error status of an asynchronous operation.</p>

<p>If the request has not yet completed, returns <code>EINPROGRESS</code>.  Otherwise,
returns <code>Ok</code> or any other error.</p>

<h1 id='examples-6' class='section-header'><a href='#examples-6'>Examples</a></h1>
<p>Issue an aio operation and use <code>error</code> to poll for completion.  Polling
is an alternative to <code>aio_suspend</code>, used by most of the other examples.</p>

<pre class="rust rust-example-rendered">
<span class="kw">const</span> <span class="ident">WBUF</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>] <span class="op">=</span> <span class="string">b&quot;abcdef123456&quot;</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">f</span> <span class="op">=</span> <span class="ident">tempfile</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">aiocb</span> <span class="op">=</span> <span class="ident">AioCb</span>::<span class="ident">from_slice</span>( <span class="ident">f</span>.<span class="ident">as_raw_fd</span>(),
    <span class="number">2</span>,   <span class="comment">//offset</span>
    <span class="ident">WBUF</span>,
    <span class="number">0</span>,   <span class="comment">//priority</span>
    <span class="ident">SigevNotify</span>::<span class="ident">SigevNone</span>,
    <span class="ident">LioOpcode</span>::<span class="ident">LIO_NOP</span>);
<span class="ident">aiocb</span>.<span class="ident">write</span>().<span class="ident">unwrap</span>();
<span class="kw">while</span> (<span class="ident">aiocb</span>.<span class="ident">error</span>() <span class="op">==</span> <span class="prelude-val">Err</span>(<span class="ident">Error</span>::<span class="ident">from</span>(<span class="ident">Errno</span>::<span class="ident">EINPROGRESS</span>))) {
    <span class="ident">thread</span>::<span class="ident">sleep</span>(<span class="ident">time</span>::<span class="ident">Duration</span>::<span class="ident">from_millis</span>(<span class="number">10</span>));
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">aiocb</span>.<span class="ident">aio_return</span>().<span class="ident">unwrap</span>() <span class="kw">as</span> <span class="ident">usize</span>, <span class="ident">WBUF</span>.<span class="ident">len</span>());</pre>

<h1 id='references-1' class='section-header'><a href='#references-1'>References</a></h1>
<p><a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/aio_error.html">aio_error</a></p>
</div><h4 id='method.fsync' class="method"><span id='fsync.v' class='invisible'><code>pub fn <a href='#method.fsync' class='fnname'>fsync</a>(&amp;mut self, mode: <a class="enum" href="../../../nix/sys/aio/enum.AioFsyncMode.html" title="enum nix::sys::aio::AioFsyncMode">AioFsyncMode</a>) -&gt; <a class="type" href="../../../nix/type.Result.html" title="type nix::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../../src/nix/sys/aio.rs.html#772-779' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p>An asynchronous version of <code>fsync(2)</code>.</p>

<h1 id='references-2' class='section-header'><a href='#references-2'>References</a></h1>
<p><a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/aio_fsync.html">aio_fsync</a></p>
</div><h4 id='method.lio_opcode' class="method"><span id='lio_opcode.v' class='invisible'><code>pub fn <a href='#method.lio_opcode' class='fnname'>lio_opcode</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="../../../nix/sys/aio/enum.LioOpcode.html" title="enum nix::sys::aio::LioOpcode">LioOpcode</a>&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../../src/nix/sys/aio.rs.html#785-792' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p>Returns the <code>aiocb</code>&#39;s <code>LioOpcode</code> field</p>

<p>If the value cannot be represented as an <code>LioOpcode</code>, returns <code>None</code>
instead.</p>
</div><h4 id='method.nbytes' class="method"><span id='nbytes.v' class='invisible'><code>pub fn <a href='#method.nbytes' class='fnname'>nbytes</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../../src/nix/sys/aio.rs.html#799-801' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p>Returns the requested length of the aio operation in bytes</p>

<p>This method returns the <em>requested</em> length of the operation.  To get the
number of bytes actually read or written by a completed operation, use
<code>aio_return</code> instead.</p>
</div><h4 id='method.offset' class="method"><span id='offset.v' class='invisible'><code>pub fn <a href='#method.offset' class='fnname'>offset</a>(&amp;self) -&gt; <a class="type" href="../../../libc/unix/notbsd/linux/other/b64/type.off_t.html" title="type libc::unix::notbsd::linux::other::b64::off_t">off_t</a></code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../../src/nix/sys/aio.rs.html#804-806' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p>Returns the file offset stored in the <code>AioCb</code></p>
</div><h4 id='method.priority' class="method"><span id='priority.v' class='invisible'><code>pub fn <a href='#method.priority' class='fnname'>priority</a>(&amp;self) -&gt; <a class="type" href="../../../libc/type.c_int.html" title="type libc::c_int">c_int</a></code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../../src/nix/sys/aio.rs.html#809-811' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p>Returns the priority of the <code>AioCb</code></p>
</div><h4 id='method.read' class="method"><span id='read.v' class='invisible'><code>pub fn <a href='#method.read' class='fnname'>read</a>(&amp;mut self) -&gt; <a class="type" href="../../../nix/type.Result.html" title="type nix::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../../src/nix/sys/aio.rs.html#818-826' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p>Asynchronously reads from a file descriptor into a buffer</p>

<h1 id='references-3' class='section-header'><a href='#references-3'>References</a></h1>
<p><a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/aio_read.html">aio_read</a></p>
</div><h4 id='method.sigevent' class="method"><span id='sigevent.v' class='invisible'><code>pub fn <a href='#method.sigevent' class='fnname'>sigevent</a>(&amp;self) -&gt; <a class="struct" href="../../../nix/sys/signal/struct.SigEvent.html" title="struct nix::sys::signal::SigEvent">SigEvent</a></code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../../src/nix/sys/aio.rs.html#829-831' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p>Returns the <code>SigEvent</code> stored in the <code>AioCb</code></p>
</div><h4 id='method.aio_return' class="method"><span id='aio_return.v' class='invisible'><code>pub fn <a href='#method.aio_return' class='fnname'>aio_return</a>(&amp;mut self) -&gt; <a class="type" href="../../../nix/type.Result.html" title="type nix::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.isize.html">isize</a>&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../../src/nix/sys/aio.rs.html#843-847' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p>Retrieve return status of an asynchronous operation.</p>

<p>Should only be called once for each <code>AioCb</code>, after <code>AioCb::error</code>
indicates that it has completed.  The result is the same as for the
synchronous <code>read(2)</code>, <code>write(2)</code>, of <code>fsync(2)</code> functions.</p>

<h1 id='references-4' class='section-header'><a href='#references-4'>References</a></h1>
<p><a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/aio_return.html">aio_return</a></p>
</div><h4 id='method.write' class="method"><span id='write.v' class='invisible'><code>pub fn <a href='#method.write' class='fnname'>write</a>(&amp;mut self) -&gt; <a class="type" href="../../../nix/type.Result.html" title="type nix::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../../src/nix/sys/aio.rs.html#854-861' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p>Asynchronously writes from a buffer to a file descriptor</p>

<h1 id='references-5' class='section-header'><a href='#references-5'>References</a></h1>
<p><a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/aio_write.html">aio_write</a></p>
</div></div>
            <h2 id='implementations' class='small-section-header'>
              Trait Implementations<a href='#implementations' class='anchor'></a>
            </h2>
        <h3 id='impl-Debug' class='impl'><span class='in-band'><code>impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="../../../nix/sys/aio/struct.AioCb.html" title="struct nix::sys::aio::AioCb">AioCb</a>&lt;'a&gt;</code><a href='#impl-Debug' class='anchor'></a></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../../src/nix/sys/aio.rs.html#1025-1039' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.fmt' class="method"><span id='fmt.v' class='invisible'><code>fn <a href='https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt' class='fnname'>fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../../src/nix/sys/aio.rs.html#1026-1038' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></p>
</div></div><h3 id='impl-Drop' class='impl'><span class='in-band'><code>impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/drop/trait.Drop.html" title="trait core::ops::drop::Drop">Drop</a> for <a class="struct" href="../../../nix/sys/aio/struct.AioCb.html" title="struct nix::sys::aio::AioCb">AioCb</a>&lt;'a&gt;</code><a href='#impl-Drop' class='anchor'></a></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../../src/nix/sys/aio.rs.html#1041-1047' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.drop' class="method"><span id='drop.v' class='invisible'><code>fn <a href='https://doc.rust-lang.org/nightly/core/ops/drop/trait.Drop.html#tymethod.drop' class='fnname'>drop</a>(&amp;mut self)</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../../src/nix/sys/aio.rs.html#1044-1046' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p>If the <code>AioCb</code> has no remaining state in the kernel, just drop it.
Otherwise, dropping constitutes a resource leak, which is an error</p>
</div></div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>↑</dt>
                    <dd>Move up in search results</dd>
                    <dt>↓</dt>
                    <dd>Move down in search results</dd>
                    <dt>↹</dt>
                    <dd>Switch tab</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                    <dt style="width:31px;">+ / -</dt>
                    <dd>Collapse/expand all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../../../";
        window.currentCrate = "nix";
    </script>
    <script src="../../../main.js"></script>
    <script defer src="../../../search-index.js"></script>
</body>
</html>